(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["basicmodule`"];


(* ::Input::Initialization:: *)
ref::usage ="ref[tag_]";
BetterFullSimplify::usage = "BetterFullSimplify[composedvars_List]";
BetterSimplify::usage ="BetterSimplify[composedvars_List,expr_,full_:0], BetterSimplify[composedvars_List]";
BetterFullSimplify::usage = "BetterFullSimplify[composedvars_List]";
ExecuteInBatch::usage = "ExecuteInBatch[in__List,body_,out_List,Options]";
ExecuteInKernel::usage = "ExecuteInKernel[modules__List,body_]";
TruncatedSave::usage = "TruncatedSave[filename_,args__]";
DefSave::usage = "DefSave[filename_,args__,Options]";
FreeQList::usage = "FreeQList[expr_,form_List]";
PrintToConsole::usage = "PrintToConsole[expr_]";
Timeit::usage = "Timeit[x_]";
ChangeofVariables::usage = "ChangeofVariables[xxold_List,xxnew_List,xxnewinold_List,mmetricold_List]";
Begin["`Private`"];


(* ::Input::Initialization:: *)
ref[tag_]:=NotebookWrite[SelectedNotebook[],RowBox[{"[",CounterBox["DisplayFormulaNumbered",ToString@tag],"]"}]];


(* ::Input::Initialization:: *)
BetterSimplify[composedvars_List,expr_,full_:0]:=Block[{z=Unique[z],replace=Unique[replace],replaceinv=Unique[replaceinv]},
(*name all expressions in composedvars*)
replaceinv=Thread[Array[z,Length[composedvars]]->composedvars];
replace=Thread[composedvars-> Array[z,Length[composedvars]]]~Join~Thread[Simplify@Expand[-composedvars]-> (-Array[z,Length[composedvars]])];
If[full==0,
Simplify[expr//.replace]//.replaceinv,
FullSimplify[expr//.replace]//.replaceinv]
];
BetterSimplify[composedvars_List]:=BetterSimplify[composedvars,#,0]&;
BetterFullSimplify[composedvars_List]:=BetterSimplify[composedvars,#,1]&;


(* ::Input::Initialization:: *)
Attributes[ExecuteInBatch] = {HoldAll};
ExecuteInBatch[in__List,body_,out_List,OptionsPattern[{scriptFilename->script ,homeDirectory -> "/Users/mbrf/Dropbox/PhD/Research/Mathematica/temp/tst"}]]:=Module[{definitionFiles,outputFile,outputtypedef,outputSymbol,scriptfileName},

SetDirectory[ OptionValue[homeDirectory]];
outputSymbol = out[[1]];
outputtypedef = out[[2]];
outputFile = ToString[outputSymbol]~~".m";
scriptfileName =  ToString[OptionValue[scriptFilename]]~~".m";

definitionFiles = ReleaseHold[(#/.List[symbol_,typedef_]:>(DefSave[ToString[HoldForm[symbol]]~~".m",symbol,typeDef-> typedef]; (ToString[HoldForm[symbol]]~~".m")))&/@If[Length[Dimensions[in]]>1,(List[ReleaseHold[ReleaseHold[Hold[in]/.List->Hold]]]/.Hold[a__]:>Hold[List[a]]),{Hold[in]}]];

List[OptionValue[homeDirectory]]/.List[attr_]:>Put[Unevaluated[SetDirectory[ attr ];],scriptfileName];

PutAppend[Unevaluated[Get["basicmodule.m"];],scriptfileName];
((Unevaluated[Get[#];])&/@definitionFiles)/.List[attr__]:>PutAppend[attr,scriptfileName];

List[outputSymbol]/.List[attr_]:>
PutAppend[Unevaluated[ attr = body;],scriptfileName];

List[outputFile,outputSymbol, typeDef->outputtypedef]/.List[args__]:>PutAppend[Unevaluated[DefSave[args];],scriptfileName];

Run["echo 'pid: ' $$ > " ~~ ToString[OptionValue[scriptFilename]]~~"-log.txt && " ~~ First[$CommandLine] ~~ " -script " ~~  scriptfileName ~~ " >> " ~~ ToString[OptionValue[scriptFilename]]~~"-log.txt &"];

ResetDirectory[];

]


(* ::Input::Initialization:: *)
Attributes[ExecuteInKernel] = {HoldAll};
ExecuteInKernel[modules__List,body_]:=Module[{definitionFiles,link,linkOut},

definitionFiles = ToString/@modules;

link = LinkLaunch[First[$CommandLine]<>" -wstp"];
LinkRead[link];

LinkWrite[link,Unevaluated@EnterExpressionPacket[Get[#]]]&/@definitionFiles;
While[!LinkReadyQ[link],Pause[0.2]];
While[LinkReadyQ[link,0.2],LinkRead[link]];


LinkWrite[link,Unevaluated@EvaluatePacket[body]];
While[!LinkReadyQ[link],Pause[0.2]];
linkOut={};
While[LinkReadyQ[link,0.2],AppendTo[linkOut,LinkRead[link]]];

LinkClose[link];
If[Length[linkOut]==1,linkOut[[1]]/.TextPacket[a_]->a/.ReturnPacket[a_]->a,DeleteCases[linkOut,ReturnPacket[Null]]/.TextPacket[a_]->a/.ReturnPacket[a_]->a]


]


(* ::Input::Initialization:: *)
SetAttributes[TruncatedSave,HoldRest]
TruncatedSave[filename_,args__]:=Block[{FullDefinition},FullDefinition=Definition;
Save[filename,args]];


(* ::Input::Initialization:: *)
SetAttributes[DefSave,HoldRest]
DefSave[filename_,args__,OptionsPattern[{typeDef-> FullDefinition}]]:=
If[OptionValue[typeDef]===Definition,
Block[{FullDefinition},FullDefinition=Definition;
Save[filename,args]],If[OptionValue[typeDef]===FullDefinition,
Save[filename,args]]];


(* ::Input::Initialization:: *)
FreeQList[expr_,form_List]:=And@@Table[FreeQ[expr,form[[i]]],{i,1,Length[form]}];


(* ::Input::Initialization:: *)
Clear[PrintToConsole]
PrintToConsole[expr_]:=(SelectionMove[MessagesNotebook[],After,Cell];
NotebookWrite[MessagesNotebook[],Cell[BoxData["During evaluation of In["<>ToString@$Line<>"]"],"CellLabel"]];
NotebookWrite[MessagesNotebook[],Cell[BoxData[ToBoxes[expr]],"Print"]]);


(* ::Input::Initialization:: *)
Timeit[x_]:=With[{t=AbsoluteTiming[x]},(PrintToConsole["Process took "<>ToString[t[[1]]]<>" seconds to complete."]; t[[2]])];
SetAttributes[Timeit,HoldAll];


(* ::Input::Initialization:: *)
ChangeofVariables[xxold_List,xxnew_List,xxnewinold_List,mmetricold_List]:=Module[{dim},
xold=xxold;
xnew=xxnew;
xnewinold=xxnewinold;
metricold=mmetricold;
dim=Length[xold];
delxnew=del/@xnew;
delxold=del/@xold;
metricoldinv=Inverse[metricold];

xoldinnew=xold/.Solve[xnew==xnewinold,xold][[1]];
(*tensor with lower indices*)
tensorlownew[tenold_,range_]:=Outer[Function[{var2},Sum[tenold@@(Array[var,range])Product[D[xoldinnew[[ var[i] ]],xnew[[var2[[i]]]]],{i,1,range}],Evaluate[Sequence@@Table[{var[i],1,dim},{i,1,range}]]]][{##}]&,Sequence@@Table[Table[iii,{iii,1,dim}],{j,1,range}]];

delxnewinold=tensorlownew[d,1]/.d[i_]:>delxold[[i]]//Simplify;
delxoldinnew=delxold/.Solve[delxnew==delxnewinold,delxold][[1]];
metricnew=tensorlownew[g,2]/.g[a__]:>metricold[[a]];
metricnewinv=Inverse[metricnew];
];


(* ::Input::Initialization:: *)
End[];
EndPackage[];
